#ifndef _VTSS_MALIBU_B__API_PLL5G_UTE
#define _VTSS_MALIBU_B__API_PLL5G_UTE

/*
Copyright (c) 2004-2018 Microsemi Corporation "Microsemi".

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/* Generation Tag is  UTE_release_vts_ute_tcllib_20180312_trunk_bjo */

/* ================================================================= *
 *               Note: This code is autogenerated from the
 *                     Universal Tcl Environment (UTE) which provides
 *                     consistent setup functions for
 *       ^             - Verification
 *      / \            - Validation
 *     /   \           - Test Pattern Generation and
 *    /  |  \          - Software
 *   /   !   \         It should not be modified manually.
 *  /_________\        In case there is a need for modifications,
 *                     please contact
 *                       Patrick Urban <patrick.urban@microsemi.com> or
 *                       Alexander Koch <alexander.koch@microsemi.com> or
 *                       Mark Venneboerger <mark.venneboerger@microsemi.com>
 *                     Please use Bugzilla for reporting issues or requesting enhancements:
 *                     Bugzilla: Tools->Victoria
 *                     http://projissuetracker/bugzilla/enter_bug.cgi?product=Victoria
 * ================================================================= */

#include <vtss/api/options.h>  // To get the ARCH define
#if defined(VTSS_ARCH_MALIBU_B)
#include "vtss_malibu_b_inc.h"


static vtss_rc  malibu_b_line_pll5g_register_cfg(vtss_state_t *vtss_state, vtss_pll5g_setup_struct_t *const res_struct, const vtss_port_no_t port_no) {

    vtss_rc rc = VTSS_RC_OK;
    u32 value;

    if( res_struct->unlock[0] == 1 ) {
    if (res_struct->pll5g_cfg2__ena_gain_test[0]) {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_ENA_GAIN_TEST,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_ENA_GAIN_TEST);
    } else {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A,
            0,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_ENA_GAIN_TEST);
    }

    CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A,
        VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_GAIN_TEST(res_struct->pll5g_cfg2__gain_test[0]),
        VTSS_M_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_GAIN_TEST);

    }  else {
    if( res_struct->lock[0] == 1 ) {
    if (res_struct->pll5g_cfg2__ena_gain_test[0]) {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_ENA_GAIN_TEST,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_ENA_GAIN_TEST);
    } else {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A,
            0,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_ENA_GAIN_TEST);
    }

    }  else {
    CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG4A,
        VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG4A_IB_CTRL(res_struct->pll5g_cfg4__ib_ctrl[0]),
        VTSS_M_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG4A_IB_CTRL);

    if (res_struct->pll5g_cfg0__ena_vco_contrh[0]) {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0A,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0A_ENA_VCO_CONTRH,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0A_ENA_VCO_CONTRH);
    } else {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0A,
            0,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0A_ENA_VCO_CONTRH);
    }

    CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0B,
        VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0B_LOOP_BW_RES(res_struct->pll5g_cfg0__loop_bw_res[0]),
        VTSS_M_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0B_LOOP_BW_RES);

    CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0B,
        VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0B_SELBGV820(res_struct->pll5g_cfg0__selbgv820[0]),
        VTSS_M_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG0B_SELBGV820);

    u32 i_var;
    for (i_var=0; i_var<=9; i_var++) {
    if (res_struct->pll5g_cfg2__disable_fsm[0]) {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_DISABLE_FSM,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_DISABLE_FSM);
    } else {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A,
            0,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_DISABLE_FSM);
    }

    if (res_struct->pll5g_cfg2__disable_fsm[1]) {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_DISABLE_FSM,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_DISABLE_FSM);
    } else {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A,
            0,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_CFG2A_DISABLE_FSM);
    }

    VTSS_MSLEEP(10);

    if (1) {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_INTR_MASK,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_INTR_MASK_LOCK_STATUS_INTR_MASK,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_INTR_MASK_LOCK_STATUS_INTR_MASK);
    } else {
        CSR_WARM_WRM(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_INTR_MASK,
            0,
            VTSS_F_LINE_PLL5G_L_PLL5G_L_PLL5G_INTR_MASK_LOCK_STATUS_INTR_MASK);
    }

    VTSS_MSLEEP(10);

    CSR_RD(port_no, VTSS_LINE_PLL5G_L_PLL5G_L_PLL5G_STATUS1B, &value);
    value = VTSS_X_LINE_PLL5G_L_PLL5G_L_PLL5G_STATUS1B_GAIN_STAT(value);


    if( value > 2 && value < 0xa) {
    break;
    } 

    }
    if( value <= 2 || value >= 0xa) {
    VTSS_E("Failed to initialize Line LCPLL as the gain was too low");
    } 

} 
} 
    if( res_struct->unlock[0] == 0 ) {
    VTSS_MSLEEP(5);

    } 


  return rc;
}

vtss_rc vtss_malibu_b_line_pll5g_setup(vtss_state_t *vtss_state, const vtss_pll5g_setup_args_t config, const vtss_port_no_t port_no) {
    vtss_pll5g_setup_struct_t calc_results;
    vtss_rc ret_val;
    VTSS_D("This function is generated with UTE based on TAG:  UTE_release_vts_ute_tcllib_20180312_trunk_bjo");
    if (config.side != VTSS_LINE) {
        VTSS_E("LSIDE function called with config.side != VTSS_LINE");
        return VTSS_RC_ERROR;
    }
    ret_val = vtss_calc_pll5g_setup(config, &calc_results);
    if(ret_val == VTSS_RC_OK) {
        ret_val |= malibu_b_line_pll5g_register_cfg(vtss_state, &calc_results, port_no);
    }
    return ret_val;
}

static vtss_rc  malibu_b_host_pll5g_register_cfg(vtss_state_t *vtss_state, vtss_pll5g_setup_struct_t *const res_struct, const vtss_port_no_t port_no) {

    vtss_rc rc = VTSS_RC_OK;
    u32 value;

    if( res_struct->unlock[0] == 1 ) {
    if (res_struct->pll5g_cfg2__ena_gain_test[0]) {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_ENA_GAIN_TEST,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_ENA_GAIN_TEST);
    } else {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A,
            0,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_ENA_GAIN_TEST);
    }

    CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A,
        VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_GAIN_TEST(res_struct->pll5g_cfg2__gain_test[0]),
        VTSS_M_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_GAIN_TEST);

    }  else {
    if( res_struct->lock[0] == 1 ) {
    if (res_struct->pll5g_cfg2__ena_gain_test[0]) {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_ENA_GAIN_TEST,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_ENA_GAIN_TEST);
    } else {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A,
            0,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_ENA_GAIN_TEST);
    }

    }  else {
    CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG4A,
        VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG4A_IB_CTRL(res_struct->pll5g_cfg4__ib_ctrl[0]),
        VTSS_M_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG4A_IB_CTRL);

    if (res_struct->pll5g_cfg0__ena_vco_contrh[0]) {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0A,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0A_ENA_VCO_CONTRH,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0A_ENA_VCO_CONTRH);
    } else {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0A,
            0,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0A_ENA_VCO_CONTRH);
    }

    CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0B,
        VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0B_LOOP_BW_RES(res_struct->pll5g_cfg0__loop_bw_res[0]),
        VTSS_M_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0B_LOOP_BW_RES);

    CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0B,
        VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0B_SELBGV820(res_struct->pll5g_cfg0__selbgv820[0]),
        VTSS_M_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG0B_SELBGV820);

    u32 i_var;
    for (i_var=0; i_var<=9; i_var++) {
    if (res_struct->pll5g_cfg2__disable_fsm[0]) {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_DISABLE_FSM,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_DISABLE_FSM);
    } else {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A,
            0,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_DISABLE_FSM);
    }

    if (res_struct->pll5g_cfg2__disable_fsm[1]) {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_DISABLE_FSM,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_DISABLE_FSM);
    } else {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A,
            0,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_CFG2A_DISABLE_FSM);
    }

    VTSS_MSLEEP(10);

    if (1) {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_INTR_MASK,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_INTR_MASK_LOCK_STATUS_INTR_MASK,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_INTR_MASK_LOCK_STATUS_INTR_MASK);
    } else {
        CSR_WARM_WRM(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_INTR_MASK,
            0,
            VTSS_F_HOST_PLL5G_H_PLL5G_H_PLL5G_INTR_MASK_LOCK_STATUS_INTR_MASK);
    }

    VTSS_MSLEEP(10);

    CSR_RD(port_no, VTSS_HOST_PLL5G_H_PLL5G_H_PLL5G_STATUS1B, &value);
    value = VTSS_X_HOST_PLL5G_H_PLL5G_H_PLL5G_STATUS1B_GAIN_STAT(value);


    if( value > 2 && value < 0xa) {
    break;
    } 

    }
    if( value <= 2 || value >= 0xa) {
    VTSS_E("Failed to initialize Host LCPLL as the gain was too low");
    } 

} 
} 
    if( res_struct->unlock[0] == 0 ) {
    VTSS_MSLEEP(5);

    } 


  return rc;
}

vtss_rc vtss_malibu_b_host_pll5g_setup(vtss_state_t *vtss_state, const vtss_pll5g_setup_args_t config, const vtss_port_no_t port_no) {
    vtss_pll5g_setup_struct_t calc_results;
    vtss_rc ret_val;
    VTSS_D("This function is generated with UTE based on TAG:  UTE_release_vts_ute_tcllib_20180312_trunk_bjo");
    if (config.side != VTSS_HOST) {
        VTSS_E("HOST side function called with config.side != VTSS_HOST");
        return VTSS_RC_ERROR;
    }
    ret_val = vtss_calc_pll5g_setup(config, &calc_results);
    if(ret_val == VTSS_RC_OK) {
        ret_val |= malibu_b_host_pll5g_register_cfg(vtss_state, &calc_results, port_no);
    }
    return ret_val;
}


#endif
#endif
