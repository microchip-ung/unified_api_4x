#ifndef _VTSS_MALIBU_REGS_F2DF_DF2F_16BIT_H_
#define _VTSS_MALIBU_REGS_F2DF_DF2F_16BIT_H_

/*


 Copyright (c) 2004-2018 Microsemi Corporation "Microsemi".

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

*/

#include "vtss_malibu_regs_common.h"

/*********************************************************************** 
 *
 * Target: \a F2DF_DF2F_16BIT
 *
 * 
 *
 ***********************************************************************/

/**
 * Register Group: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST
 *
 * SD10G65 RX and TX RCPLL BIST Configuration and Status Register set
 */


/** 
 * \brief SD10G65 RX RCPLL BIST Configuration register 0A
 *
 * \details
 * Configuration register 0A for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_CFG0A
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_CFG0A  VTSS_IOREG(0x1e, 0, 0xee00)


/** 
 * \brief SD10G65 RX RCPLL BIST Configuration register 0B
 *
 * \details
 * Configuration register 0B for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_CFG0B
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_CFG0B  VTSS_IOREG(0x1e, 0, 0xee01)


/** 
 * \brief SD10G65 RX RCPLL BIST Configuration register 1A
 *
 * \details
 * Configuration register 1A for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_CFG1A
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_CFG1A  VTSS_IOREG(0x1e, 0, 0xee02)


/** 
 * \brief SD10G65 RX RCPLL BIST Configuration register 1B
 *
 * \details
 * Configuration register 1B for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_CFG1B
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_CFG1B  VTSS_IOREG(0x1e, 0, 0xee03)


/** 
 * \brief SD10G65 RX RCPLL BIST Configuration register 2
 *
 * \details
 * Configuration register 2 for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_CFG2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_CFG2  VTSS_IOREG(0x1e, 0, 0xee04)


/** 
 * \brief SD10G65 RX RCPLL BIST Configuration register 3
 *
 * \details
 * Configuration register 3 for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_CFG3
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_CFG3  VTSS_IOREG(0x1e, 0, 0xee05)


/** 
 * \brief SD10G65 RX RCPLL BIST Configuration register 4
 *
 * \details
 * Configuration register 4 for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_CFG4
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_CFG4  VTSS_IOREG(0x1e, 0, 0xee06)


/** 
 * \brief SD10G65 RX RCPLL BIST Status register 0A
 *
 * \details
 * Status register 0A for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_STAT0A
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_STAT0A  VTSS_IOREG(0x1e, 0, 0xee07)


/** 
 * \brief SD10G65 RX RCPLL BIST Status register 0B
 *
 * \details
 * Status register 0B for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_STAT0B
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_STAT0B  VTSS_IOREG(0x1e, 0, 0xee08)


/** 
 * \brief SD10G65 RX RCPLL BIST Status register 1
 *
 * \details
 * Status register 1 for SD10G65 RX RCPLL BIST.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_RX_RCPLL_BIST:SD10G65_RX_RCPLL_BIST_STAT1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_RX_RCPLL_BIST_SD10G65_RX_RCPLL_BIST_STAT1  VTSS_IOREG(0x1e, 0, 0xee09)

/**
 * Register Group: \a F2DF_DF2F_16BIT:F2DF_DF2F_CFG
 *
 * Configuration registers for the F2DF and DF2F logic
 */


/** 
 * \brief Portion of parallel data transmitted from SCKOUT output
 *
 * \details
 * Register: \a F2DF_DF2F_16BIT:F2DF_DF2F_CFG:DF2F_DOUT_C
 */
#define VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_C  VTSS_IOREG(0x1e, 0, 0xee30)

/** 
 * \brief
 * A repeating parallel data word up to 40 bits long is serialized and
 * transmitted from the SCKOUT output.	This register contains bits [39:32]
 * of the parallel data word.
 *
 * \details 
 * Clock freequency transmitted from the pin depends upon both the parallel
 * data word setting and the serializer configuration.
 *
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_C . DF2F_DOUT_C
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_C_DF2F_DOUT_C(x)  VTSS_ENCODE_BITFIELD(x,0,8)
#define  VTSS_M_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_C_DF2F_DOUT_C     VTSS_ENCODE_BITMASK(0,8)
#define  VTSS_X_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_C_DF2F_DOUT_C(x)  VTSS_EXTRACT_BITFIELD(x,0,8)


/** 
 * \brief Portion of parallel data transmitted from SCKOUT output
 *
 * \details
 * Register: \a F2DF_DF2F_16BIT:F2DF_DF2F_CFG:DF2F_DOUT_B
 */
#define VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_B  VTSS_IOREG(0x1e, 0, 0xee31)

/** 
 * \brief
 * A repeating parallel data word up to 40 bits long is serialized and
 * transmitted from the SCKOUT output.	This register contains bits [31:16]
 * of the parallel data word.
 *
 * \details 
 * Clock freequency transmitted from the pin depends upon both the parallel
 * data word setting and the serializer configuration.
 *
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_B . DF2F_DOUT_B
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_B_DF2F_DOUT_B(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_B_DF2F_DOUT_B     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_B_DF2F_DOUT_B(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief Portion of parallel data transmitted from SCKOUT output
 *
 * \details
 * Register: \a F2DF_DF2F_16BIT:F2DF_DF2F_CFG:DF2F_DOUT_A
 */
#define VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_A  VTSS_IOREG(0x1e, 0, 0xee32)

/** 
 * \brief
 * A repeating parallel data word up to 40 bits long is serialized and
 * transmitted from the SCKOUT output.	This register contains bits [15:0]
 * of the parallel data word.
 *
 * \details 
 * Clock freequency transmitted from the pin depends upon both the parallel
 * data word setting and the serializer configuration.
 *
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_A . DF2F_DOUT_A
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_A_DF2F_DOUT_A(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_A_DF2F_DOUT_A     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DF2F_DOUT_A_DF2F_DOUT_A(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 Spread Sprectrum Clocking
 *
 * \details
 * SD10G65 Spread Sprectrum Clocking
 *
 * Register: \a F2DF_DF2F_16BIT:F2DF_DF2F_CFG:SD10G65_SSC_SYNC
 */
#define VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SSC_SYNC  VTSS_IOREG(0x1e, 0, 0xee33)

/** 
 * \brief
 * Spread Spectrum Clocking Output
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SSC_SYNC . SSC_SYNC_STAT
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SSC_SYNC_SSC_SYNC_STAT  VTSS_BIT(4)

/** 
 * \brief
 * Spread Spectrum Clocking Input
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SSC_SYNC . SSC_SYNC_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SSC_SYNC_SSC_SYNC_CFG  VTSS_BIT(0)


/** 
 * \brief SD10G65 Smooth Clocking Update
 *
 * \details
 * SD10G65 Smooth Clocking Update
 *
 * Register: \a F2DF_DF2F_16BIT:F2DF_DF2F_CFG:SD10G65_SMOOTH_UPDATE
 */
#define VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_UPDATE  VTSS_IOREG(0x1e, 0, 0xee34)

/** 
 * \brief
 * Smooth Update
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_UPDATE . SMOOTH_UPDATE
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_UPDATE_SMOOTH_UPDATE  VTSS_BIT(0)


/** 
 * \brief SD10G65 Smooth Clocking Value MSB
 *
 * \details
 * SD10G65 Smooth Clocking Value MSB
 *
 * Register: \a F2DF_DF2F_16BIT:F2DF_DF2F_CFG:SD10G65_SMOOTH_VALUE_MSB
 */
#define VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_MSB  VTSS_IOREG(0x1e, 0, 0xee35)

/** 
 * \brief
 * Smooth Clocking Value MSB bit [22:16]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_MSB . SMOOTH_VALUE_MSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_MSB_SMOOTH_VALUE_MSB(x)  VTSS_ENCODE_BITFIELD(x,0,7)
#define  VTSS_M_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_MSB_SMOOTH_VALUE_MSB     VTSS_ENCODE_BITMASK(0,7)
#define  VTSS_X_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_MSB_SMOOTH_VALUE_MSB(x)  VTSS_EXTRACT_BITFIELD(x,0,7)


/** 
 * \brief SD10G65 Smooth Clocking Value LSB
 *
 * \details
 * SD10G65 Smooth Clocking Value LSB
 *
 * Register: \a F2DF_DF2F_16BIT:F2DF_DF2F_CFG:SD10G65_SMOOTH_VALUE_LSB
 */
#define VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_LSB  VTSS_IOREG(0x1e, 0, 0xee36)

/** 
 * \brief
 * Smooth Clocking Value LSB bit [15:0]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_LSB . SMOOTH_VALUE_LSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_LSB_SMOOTH_VALUE_LSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_LSB_SMOOTH_VALUE_LSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_SD10G65_SMOOTH_VALUE_LSB_SMOOTH_VALUE_LSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief Debug mux signal selection
 *
 * \details
 * Register: \a F2DF_DF2F_16BIT:F2DF_DF2F_CFG:DBG_MUX_SEL
 */
#define VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_CFG_DBG_MUX_SEL  VTSS_IOREG(0x1e, 0, 0xee37)

/**
 * Register Group: \a F2DF_DF2F_16BIT:F2DF_DF2F_STAT
 *
 * Status registers for the F2DF and DF2F logic
 */


/** 
 * \brief Status
 *
 * \details
 * Register: \a F2DF_DF2F_16BIT:F2DF_DF2F_STAT:F2DF_DF2F_STAT1
 */
#define VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_STAT_F2DF_DF2F_STAT1  VTSS_IOREG(0x1e, 0, 0xee40)

/** 
 * \brief
 * Indicates PLL lock status for the DF2F serializer.
 *
 * \details 
 * 1 = Locked
 * 0 = Not locked
 *
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_STAT_F2DF_DF2F_STAT1 . PLL_LOCK_TX
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_STAT_F2DF_DF2F_STAT1_PLL_LOCK_TX  VTSS_BIT(4)

/** 
 * \brief
 * Signal detect status from the F2DF deserializer.
 *
 * \details 
 * 1 = Signal detected
 * 0 = Signal not detected
 *
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_STAT_F2DF_DF2F_STAT1 . F2DF_SIG_DET
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_STAT_F2DF_DF2F_STAT1_F2DF_SIG_DET  VTSS_BIT(1)

/** 
 * \brief
 * Indicates PLL lock status for the F2DF deserializer.
 *
 * \details 
 * 1 = Locked
 * 0 = Not locked
 *
 * Field: VTSS_F2DF_DF2F_16BIT_F2DF_DF2F_STAT_F2DF_DF2F_STAT1 . PLL_LOCK_RX
 */
#define  VTSS_F_F2DF_DF2F_16BIT_F2DF_DF2F_STAT_F2DF_DF2F_STAT1_PLL_LOCK_RX  VTSS_BIT(0)

/**
 * Register Group: \a F2DF_DF2F_16BIT:SD10G65_DFT
 *
 * SD10G65 DFT Configuration and Status Register set
 */


/** 
 * \brief SD10G65 DFT Main configuration register 1
 *
 * \details
 * Main configuration register 1 for SD10G65 DFT.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_RX_CFG_1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1  VTSS_IOREG(0x1e, 0, 0xee50)

/** 
 * \brief
 * Disables error generation based on stuck_at_par errors,
 *
 * \details 
 * 0: stuck_at_par error generates 63 errors per clock cycle (in PRBS mode
 * only)
 * 1: stuck_at_par error does not generate errors
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1 . STUCK_AT_PAR_MASK_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_STUCK_AT_PAR_MASK_CFG  VTSS_BIT(12)

/** 
 * \brief
 * Disables error generation based on stuck_at_01 errors,
 *
 * \details 
 * 0: stuck_at_01 error generates 63 errors per clock cycle (in PRBS mode
 * only)
 * 1: stuck_at_01 error does not generate errors
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1 . STUCK_AT_01_MASK_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_STUCK_AT_01_MASK_CFG  VTSS_BIT(11)

/** 
 * \brief
 * Enables data through from gearbox to gearbox
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1 . DIRECT_THROUGH_ENA_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_DIRECT_THROUGH_ENA_CFG  VTSS_BIT(10)

/** 
 * \brief
 * Captures data from error counter to allow reading of stable data
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1 . ERR_CNT_CAPT_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_ERR_CNT_CAPT_CFG  VTSS_BIT(9)

/** 
 * \brief
 * Data source selection
 *
 * \details 
 * 0: main path
 * 1: vscope high path
 * 2: vscope low path
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1 . RX_DATA_SRC_SEL
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_RX_DATA_SRC_SEL(x)  VTSS_ENCODE_BITFIELD(x,7,2)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_RX_DATA_SRC_SEL     VTSS_ENCODE_BITMASK(7,2)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_RX_DATA_SRC_SEL(x)  VTSS_EXTRACT_BITFIELD(x,7,2)

/** 
 * \brief
 * States in which error counting is enabled
 *
 * \details 
 * 3:all but IDLE; 2:check 1:stable+check
 * 0:wait_stable+stable+check
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1 . BIST_CNT_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_BIST_CNT_CFG(x)  VTSS_ENCODE_BITFIELD(x,5,2)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_BIST_CNT_CFG     VTSS_ENCODE_BITMASK(5,2)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_BIST_CNT_CFG(x)  VTSS_EXTRACT_BITFIELD(x,5,2)

/** 
 * \brief
 * Disable change of stored patterns (e.g. to avoid changes during
 * read-out)
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1 . FREEZE_PATTERN_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_FREEZE_PATTERN_CFG  VTSS_BIT(4)

/** 
 * \brief
 * Selects pattern to check
 *
 * \details 
 * 0: PRBS pattern
 * 1: constant pattern
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1 . CHK_MODE_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_CHK_MODE_CFG  VTSS_BIT(3)

/** 
 * \brief
 * Selects DES interface width
 *
 * \details 
 * 0:8
 * 1:10
 * 2:16
 * 3:20
 * 4:32
 * 5:40 (default)
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1 . RX_WID_SEL_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_RX_WID_SEL_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,3)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_RX_WID_SEL_CFG     VTSS_ENCODE_BITMASK(0,3)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_1_RX_WID_SEL_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,3)


/** 
 * \brief SD10G65 DFT Main configuration register 2
 *
 * \details
 * Main configuration register 2 for SD10G65 DFT.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_RX_CFG_2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2  VTSS_IOREG(0x1e, 0, 0xee51)

/** 
 * \brief
 * Pattern generator: 0:bytes mode; 1:10-bits word mode
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2 . RX_WORD_MODE_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_RX_WORD_MODE_CFG  VTSS_BIT(14)

/** 
 * \brief
 * Selects PRBS check
 *
 * \details 
 * 0: prbs7
 * 1: prbs15
 * 2: prbs23
 * 3: prbs11
 * 4: prbs31 (default)
 * 5: prbs9
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2 . RX_PRBS_SEL_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_RX_PRBS_SEL_CFG(x)  VTSS_ENCODE_BITFIELD(x,11,3)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_RX_PRBS_SEL_CFG     VTSS_ENCODE_BITMASK(11,3)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_RX_PRBS_SEL_CFG(x)  VTSS_EXTRACT_BITFIELD(x,11,3)

/** 
 * \brief
 * Enables PRBS checker input inversion
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2 . INV_ENA_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_INV_ENA_CFG  VTSS_BIT(10)

/** 
 * \brief
 * Selects compare mode
 *
 * \details 
 * 0: compare mode possible
 * 1 learn mode is forced
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2 . CMP_MODE_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_CMP_MODE_CFG  VTSS_BIT(9)

/** 
 * \brief
 * Number of consecutive errors/non-errors before transitioning to
 * respective state
 *
 * \details 
 * value = num-40-bits-words + 1
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2 . LRN_CNT_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_LRN_CNT_CFG(x)  VTSS_ENCODE_BITFIELD(x,6,3)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_LRN_CNT_CFG     VTSS_ENCODE_BITMASK(6,3)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_LRN_CNT_CFG(x)  VTSS_EXTRACT_BITFIELD(x,6,3)

/** 
 * \brief
 * SW reset of error counter; rising edge activates reset
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2 . CNT_RST
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_CNT_RST  VTSS_BIT(5)

/** 
 * \brief
 * Selects modes in which error counter is active
 *
 * \details 
 * 0:learn and compare mode
 * 1:transition between modes
 * 2:learn mode
 * 3:compare mode
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2 . CNT_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_CNT_CFG(x)  VTSS_ENCODE_BITFIELD(x,3,2)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_CNT_CFG     VTSS_ENCODE_BITMASK(3,2)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_CNT_CFG(x)  VTSS_EXTRACT_BITFIELD(x,3,2)

/** 
 * \brief
 * BIST mode
 *
 * \details 
 * 0: off
 * 1: BIST
 * 2: BER
 * 3:CONT (infinite mode)
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2 . BIST_MODE_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_BIST_MODE_CFG(x)  VTSS_ENCODE_BITFIELD(x,1,2)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_BIST_MODE_CFG     VTSS_ENCODE_BITMASK(1,2)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_BIST_MODE_CFG(x)  VTSS_EXTRACT_BITFIELD(x,1,2)

/** 
 * \brief
 * Enable RX DFT capability
 *
 * \details 
 * 0: Disable DFT
 * 1: Enable DFT
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2 . DFT_RX_ENA
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_CFG_2_DFT_RX_ENA  VTSS_BIT(0)


/** 
 * \brief SD10G65 DFT pattern mask configuration register 1 
 *
 * \details
 * Configuration register 1 for SD10G65 DFT to mask data bits preventing
 * error counting for these bits.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_RX_MASK_CFG_1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_1  VTSS_IOREG(0x1e, 0, 0xee52)

/** 
 * \brief
 * Mask out (active high) errors in 16 bit MSB data bits [31:16]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_1 . LSB_MASK_CFG_1
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_1_LSB_MASK_CFG_1(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_1_LSB_MASK_CFG_1     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_1_LSB_MASK_CFG_1(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT pattern mask configuration register 2
 *
 * \details
 * Configuration register 2 for SD10G65 DFT to mask data bits preventing
 * error counting for these bits.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_RX_MASK_CFG_2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_2  VTSS_IOREG(0x1e, 0, 0xee53)

/** 
 * \brief
 * Mask out (active high) errors in 16 LSB data bits [15:0]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_2 . LSB_MASK_CFG_2
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_2_LSB_MASK_CFG_2(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_2_LSB_MASK_CFG_2     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_MASK_CFG_2_LSB_MASK_CFG_2(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT Pattern checker configuration register 1
 *
 * \details
 * Pattern checker configuration register 1 for SD10G65 DFT.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_RX_PAT_CFG_1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_1  VTSS_IOREG(0x1e, 0, 0xee54)

/** 
 * \brief
 * Mask out (active high) errors in 8 MSB data bits
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_1 . MSB_MASK_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_1_MSB_MASK_CFG(x)  VTSS_ENCODE_BITFIELD(x,8,8)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_1_MSB_MASK_CFG     VTSS_ENCODE_BITMASK(8,8)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_1_MSB_MASK_CFG(x)  VTSS_EXTRACT_BITFIELD(x,8,8)

/** 
 * \brief
 * Pattern read enable
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_1 . PAT_READ_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_1_PAT_READ_CFG  VTSS_BIT(0)


/** 
 * \brief SD10G65 DFT Pattern checker configuration register 2
 *
 * \details
 * Pattern checker configuration register 2 for SD10G65 DFT.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_RX_PAT_CFG_2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_2  VTSS_IOREG(0x1e, 0, 0xee55)

/** 
 * \brief
 * Maximum address in Checker (before continuing with address 0)
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_2 . MAX_ADDR_CHK_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_2_MAX_ADDR_CHK_CFG(x)  VTSS_ENCODE_BITFIELD(x,8,4)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_2_MAX_ADDR_CHK_CFG     VTSS_ENCODE_BITMASK(8,4)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_2_MAX_ADDR_CHK_CFG(x)  VTSS_EXTRACT_BITFIELD(x,8,4)

/** 
 * \brief
 * Address to read patterns from used by SW
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_2 . READ_ADDR_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_2_READ_ADDR_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,4)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_2_READ_ADDR_CFG     VTSS_ENCODE_BITMASK(0,4)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_RX_PAT_CFG_2_READ_ADDR_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,4)


/** 
 * \brief SD10G65 DFT BIST configuration register A
 *
 * \details
 * BIST configuration register A for SD10G65 DFT controlling 'check and
 * wait-stable' mode.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_BIST_CFG0A
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0A  VTSS_IOREG(0x1e, 0, 0xee56)

/** 
 * \brief
 * BIST FSM: threshold to leave DOZE state
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0A . WAKEUP_DLY_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0A_WAKEUP_DLY_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0A_WAKEUP_DLY_CFG     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0A_WAKEUP_DLY_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT BIST configuration register B
 *
 * \details
 * BIST configuration register B for SD10G65 DFT controlling 'check and
 * wait-stable' mode.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_BIST_CFG0B
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0B  VTSS_IOREG(0x1e, 0, 0xee57)

/** 
 * \brief
 * BIST FSM: threshold to enter FINISHED state
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0B . MAX_BIST_FRAMES_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0B_MAX_BIST_FRAMES_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0B_MAX_BIST_FRAMES_CFG     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG0B_MAX_BIST_FRAMES_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT BIST configuration register A
 *
 * \details
 * BIST configuration register A for SD10G65 DFT  controlling 'stable'
 * mode.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_BIST_CFG1A
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1A  VTSS_IOREG(0x1e, 0, 0xee58)

/** 
 * \brief
 * BIST FSM: threshold to iterate counter for max_stable_attempts
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1A . MAX_UNSTABLE_CYC_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1A_MAX_UNSTABLE_CYC_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1A_MAX_UNSTABLE_CYC_CFG     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1A_MAX_UNSTABLE_CYC_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT BIST configuration register B
 *
 * \details
 * BIST configuration register B for SD10G65 DFT  controlling 'stable'
 * mode.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_BIST_CFG1B
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1B  VTSS_IOREG(0x1e, 0, 0xee59)

/** 
 * \brief
 * BIST FSM: threshold to enter CHECK state
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1B . STABLE_THRES_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1B_STABLE_THRES_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1B_STABLE_THRES_CFG     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG1B_STABLE_THRES_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT BIST configuration register A
 *
 * \details
 * BIST configuration register B for SD10G65 DFT controlling frame length
 * in 'check' mode.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_BIST_CFG2A
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2A  VTSS_IOREG(0x1e, 0, 0xee5a)

/** 
 * \brief
 * BIST FSM: threshold to iterate counter for max_bist_frames [31:16]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2A . FRAME_LEN_CFG_MSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2A_FRAME_LEN_CFG_MSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2A_FRAME_LEN_CFG_MSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2A_FRAME_LEN_CFG_MSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT BIST configuration register B
 *
 * \details
 * BIST configuration register B for SD10G65 DFT controlling frame length
 * in 'check' mode.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_BIST_CFG2B
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2B  VTSS_IOREG(0x1e, 0, 0xee5b)

/** 
 * \brief
 * BIST FSM: threshold to iterate counter for max_bist_frames [15:0]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2B . FRAME_LEN_CFG_LSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2B_FRAME_LEN_CFG_LSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2B_FRAME_LEN_CFG_LSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG2B_FRAME_LEN_CFG_LSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT BIST configuration register A
 *
 * \details
 * BIST configuration register A for SD10G65 DFT controlling stable
 * attempts in ' wait-stable' mode.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_BIST_CFG3A
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3A  VTSS_IOREG(0x1e, 0, 0xee5c)

/** 
 * \brief
 * BIST FSM: threshold to enter SYNC_ERR state [31:16]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3A . MAX_STABLE_ATTEMPTS_CFG_MSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3A_MAX_STABLE_ATTEMPTS_CFG_MSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3A_MAX_STABLE_ATTEMPTS_CFG_MSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3A_MAX_STABLE_ATTEMPTS_CFG_MSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT BIST configuration register B
 *
 * \details
 * BIST configuration register B for SD10G65 DFT controlling stable
 * attempts in ' wait-stable' mode.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_BIST_CFG3B
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3B  VTSS_IOREG(0x1e, 0, 0xee5d)

/** 
 * \brief
 * BIST FSM: threshold to enter SYNC_ERR state [15:0]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3B . MAX_STABLE_ATTEMPTS_CFG_LSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3B_MAX_STABLE_ATTEMPTS_CFG_LSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3B_MAX_STABLE_ATTEMPTS_CFG_LSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_BIST_CFG3B_MAX_STABLE_ATTEMPTS_CFG_LSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT error status register 1
 *
 * \details
 * Status register 1 for SD10G65 DFT containing the error counter value
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_ERR_STAT_1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_1  VTSS_IOREG(0x1e, 0, 0xee5e)

/** 
 * \brief
 * Counter output depending on cnt_cfg [31:16]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_1 . ERR_CNT_MSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_1_ERR_CNT_MSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_1_ERR_CNT_MSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_1_ERR_CNT_MSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT error status register 2
 *
 * \details
 * Status register B2 for SD10G65 DFT containing the error counter value
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_ERR_STAT_2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_2  VTSS_IOREG(0x1e, 0, 0xee5f)

/** 
 * \brief
 * Counter output depending on cnt_cfg [15:0]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_2 . ERR_CNT_LSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_2_ERR_CNT_LSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_2_ERR_CNT_LSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_ERR_STAT_2_ERR_CNT_LSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT PRBS status register 1
 *
 * \details
 * Status register 1 for SD10G65 DFT containing the PRBS data related to
 * 1st sync lost event
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_PRBS_STAT_1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_1  VTSS_IOREG(0x1e, 0, 0xee60)

/** 
 * \brief
 * PRBS data after first sync lost [31:16]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_1 . PRBS_DATA_STAT_MSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_1_PRBS_DATA_STAT_MSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_1_PRBS_DATA_STAT_MSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_1_PRBS_DATA_STAT_MSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT PRBS status register 2
 *
 * \details
 * Status register 2 for SD10G65 DFT containing the PRBS data related to
 * 1st sync lost event
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_PRBS_STAT_2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_2  VTSS_IOREG(0x1e, 0, 0xee61)

/** 
 * \brief
 * PRBS data after first sync lost [15:0]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_2 . PRBS_DATA_STAT_LSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_2_PRBS_DATA_STAT_LSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_2_PRBS_DATA_STAT_LSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_PRBS_STAT_2_PRBS_DATA_STAT_LSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief SD10G65 DFT miscellaneous status register 1
 *
 * \details
 * Status register 1 for SD10G65 DFT
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_MAIN_STAT_1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_1  VTSS_IOREG(0x1e, 0, 0xee62)

/** 
 * \brief
 * 10 bits data word at address 'read_addr_cfg' used for further
 * observation by SW
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_1 . CMP_DATA_STAT
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_1_CMP_DATA_STAT(x)  VTSS_ENCODE_BITFIELD(x,0,10)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_1_CMP_DATA_STAT     VTSS_ENCODE_BITMASK(0,10)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_1_CMP_DATA_STAT(x)  VTSS_EXTRACT_BITFIELD(x,0,10)


/** 
 * \brief SD10G65 DFT miscellaneous status register 2
 *
 * \details
 * Status register 2 for SD10G65 DFT
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_MAIN_STAT_2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2  VTSS_IOREG(0x1e, 0, 0xee63)

/** 
 * \brief
 * Data input is unchanged for all 40 parallel bits for at least 7 clock
 * cycles (defined by c_STCK_CNT_THRES)
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2 . STUCK_AT_PAR
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2_STUCK_AT_PAR  VTSS_BIT(5)

/** 
 * \brief
 * Data input is constantly 0 or constantly 1 for all 40 parallel bits for
 * at least 7 clock cycles (defined by c_STCK_CNT_THRES)
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2 . STUCK_AT_01
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2_STUCK_AT_01  VTSS_BIT(4)

/** 
 * \brief
 * BIST: no sync found since BIST enabled
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2 . NO_SYNC
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2_NO_SYNC  VTSS_BIT(3)

/** 
 * \brief
 * BIST: input data not stable
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2 . INSTABLE
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2_INSTABLE  VTSS_BIT(2)

/** 
 * \brief
 * BIST not complete (i.e. not reached stable state or following)
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2 . INCOMPLETE
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2_INCOMPLETE  VTSS_BIT(1)

/** 
 * \brief
 * BIST is active (i.e. left DOZE but did not enter a final state)
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2 . ACTIVE
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_MAIN_STAT_2_ACTIVE  VTSS_BIT(0)


/** 
 * \brief SD10G65 DFT Main configuration register
 *
 * \details
 * Main configuration register for SD10G65 DFT.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_TX_CFG
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG  VTSS_IOREG(0x1e, 0, 0xee64)

/** 
 * \brief
 * Enables (1) reset of PRBS generator in case of unchanged data
 * ('stuck-at') for at least 511 clock cycles. Can be disabled (0) e.g. in
 * scrambler mode to avoid the very rare case that input patterns allow to
 * keep the generator's shift register filled with a constant value.
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG . RST_ON_STUCK_AT_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_RST_ON_STUCK_AT_CFG  VTSS_BIT(12)

/** 
 * \brief
 * Selects SER interface width
 *
 * \details 
 * 0:8
 * 1:10
 * 2:16
 * 3:20
 * 4:32
 * 5:40 (default)
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG . TX_WID_SEL_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_TX_WID_SEL_CFG(x)  VTSS_ENCODE_BITFIELD(x,9,3)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_TX_WID_SEL_CFG     VTSS_ENCODE_BITMASK(9,3)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_TX_WID_SEL_CFG(x)  VTSS_EXTRACT_BITFIELD(x,9,3)

/** 
 * \brief
 * Selects PRBS generator
 *
 * \details 
 * 0: prbs7
 * 1: prbs15
 * 2: prbs23
 * 3: prbs11
 * 4: prbs31 (default)
 * 5: prbs9
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG . TX_PRBS_SEL_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_TX_PRBS_SEL_CFG(x)  VTSS_ENCODE_BITFIELD(x,6,3)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_TX_PRBS_SEL_CFG     VTSS_ENCODE_BITMASK(6,3)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_TX_PRBS_SEL_CFG(x)  VTSS_EXTRACT_BITFIELD(x,6,3)

/** 
 * \brief
 * Inverts the scrambler output
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG . SCRAM_INV_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_SCRAM_INV_CFG  VTSS_BIT(5)

/** 
 * \brief
 * Selects PRBS generator input
 *
 * \details 
 * 0:pat-gen
 * 1:core
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG . IPATH_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_IPATH_CFG  VTSS_BIT(4)

/** 
 * \brief
 * Selects DFT-TX output
 *
 * \details 
 * 0:PRBS/scrambler (default)
 * 1:bypass

 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG . OPATH_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_OPATH_CFG(x)  VTSS_ENCODE_BITFIELD(x,2,2)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_OPATH_CFG     VTSS_ENCODE_BITMASK(2,2)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_OPATH_CFG(x)  VTSS_EXTRACT_BITFIELD(x,2,2)

/** 
 * \brief
 * Word width of constant pattern generator
 *
 * \details 
 * 0:bytes mode; 1:10-bits word mode
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG . TX_WORD_MODE_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_TX_WORD_MODE_CFG  VTSS_BIT(1)

/** 
 * \brief
 * Enable TX DFT capability
 *
 * \details 
 * 0: Disable DFT
 * 1: Enable DFT
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG . DFT_TX_ENA
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CFG_DFT_TX_ENA  VTSS_BIT(0)


/** 
 * \brief SD10G65 DFT TX Constant pattern configuration register 1
 *
 * \details
 * TX Constant MSB pattern configuration register 1 for SD10G65 DFT.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_TX_PAT_CFG_1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_1  VTSS_IOREG(0x1e, 0, 0xee65)

/** 
 * \brief
 * Constant patterns are valid to store
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_1 . PAT_VLD_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_1_PAT_VLD_CFG  VTSS_BIT(4)

/** 
 * \brief
 * Maximum address in generator (before continuing with address 0)
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_1 . MAX_ADDR_GEN_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_1_MAX_ADDR_GEN_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,4)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_1_MAX_ADDR_GEN_CFG     VTSS_ENCODE_BITMASK(0,4)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_1_MAX_ADDR_GEN_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,4)


/** 
 * \brief SD10G65 DFT TX Constant pattern configuration register 2
 *
 * \details
 * TX Constant MSB pattern configuration register 2 for SD10G65 DFT.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_TX_PAT_CFG_2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_2  VTSS_IOREG(0x1e, 0, 0xee66)

/** 
 * \brief
 * Current storage address for patterns in generator
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_2 . STORE_ADDR_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_2_STORE_ADDR_CFG(x)  VTSS_ENCODE_BITFIELD(x,10,4)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_2_STORE_ADDR_CFG     VTSS_ENCODE_BITMASK(10,4)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_2_STORE_ADDR_CFG(x)  VTSS_EXTRACT_BITFIELD(x,10,4)

/** 
 * \brief
 * 10 bits word of constant patterns for transmission
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_2 . PATTERN_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_2_PATTERN_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,10)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_2_PATTERN_CFG     VTSS_ENCODE_BITMASK(0,10)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_PAT_CFG_2_PATTERN_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,10)


/** 
 * \brief SD10G65 DFT TX constant pattern status register
 *
 * \details
 * Status register for SD10G65 DFT containing the constant patterns used
 * for comparison (last in LEARN mode)
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_TX_CMP_DAT_STAT
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CMP_DAT_STAT  VTSS_IOREG(0x1e, 0, 0xee67)

/** 
 * \brief
 * Scrambler/PRBS generator output unchanged for at least 511 clock cycles.
 *  The high state is cleared by writing a 1 to the bit.
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CMP_DAT_STAT . TX_STUCK_AT_STICKY
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CMP_DAT_STAT_TX_STUCK_AT_STICKY  VTSS_BIT(12)

/** 
 * \brief
 * 10 bits data word at address 'store_addr_cfg' used for further
 * observation by SW
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CMP_DAT_STAT . PAT_STAT
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CMP_DAT_STAT_PAT_STAT(x)  VTSS_ENCODE_BITFIELD(x,0,10)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CMP_DAT_STAT_PAT_STAT     VTSS_ENCODE_BITMASK(0,10)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_CMP_DAT_STAT_PAT_STAT(x)  VTSS_EXTRACT_BITFIELD(x,0,10)


/** 
 * \brief DFT clock compare config
 *
 * \details
 * Configuration register for Clock Compare logic. Compared clocks are
 * always divided by 4 before any further processing. A clock edge on
 * tx_clk increments the counter, a clock edge on rx_clk decrements the
 * counter. If only one clock is selected for clock comparison, the number
 * of clock cycles within a given time can be measured.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_CMP_CFG
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG  VTSS_IOREG(0x1e, 0, 0xee68)

/** 
 * \brief
 * Clock compare value updated toggle bit. Toggles on each update of
 * CLK_CMP_VALUE
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG . CLK_CMP_UPDTOG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG_CLK_CMP_UPDTOG  VTSS_BIT(12)

/** 
 * \brief
 * Clock compare selection
 *
 * \details 
 * 0: rx_clk vs. tx_clk
 * 1: rx_clk
 * 2: tx_clk
 * 3: Reserved
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG . CLK_CMP_SEL
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG_CLK_CMP_SEL(x)  VTSS_ENCODE_BITFIELD(x,2,2)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG_CLK_CMP_SEL     VTSS_ENCODE_BITMASK(2,2)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG_CLK_CMP_SEL(x)  VTSS_EXTRACT_BITFIELD(x,2,2)

/** 
 * \brief
 * Clock comparison mode
 *
 * \details 
 * 0: single shot
 * 1: continuous
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG . CLK_CMP_MODE
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG_CLK_CMP_MODE  VTSS_BIT(1)

/** 
 * \brief
 * Enable clock comparison (enabling automatically clears comparison
 * counter)
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG . CLK_CMP_ENA
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_CFG_CLK_CMP_ENA  VTSS_BIT(0)


/** 
 * \brief DFT clock compare timer
 *
 * \details
 * Upper half of clock comparison timer.  After timer has expired, current
 * clock comparison value is stored.  The timer is clocked at 156.25 MHz.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_CMP_TIMERA
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERA  VTSS_IOREG(0x1e, 0, 0xee69)

/** 
 * \brief
 * Clock comparison timer, bits [31:16]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERA . CLK_CMP_TIMER_MSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERA_CLK_CMP_TIMER_MSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERA_CLK_CMP_TIMER_MSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERA_CLK_CMP_TIMER_MSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief DFT clock compare timer
 *
 * \details
 * Lower half of clock comparison timer.  After timer has expired, current
 * clock comparison value is stored.  The timer is clocked at 156.25 MHz.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_CMP_TIMERB
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERB  VTSS_IOREG(0x1e, 0, 0xee6a)

/** 
 * \brief
 * Clock comparison timer, bits [15:0]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERB . CLK_CMP_TIMER_LSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERB_CLK_CMP_TIMER_LSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERB_CLK_CMP_TIMER_LSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_TIMERB_CLK_CMP_TIMER_LSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief DFT clock comparison value
 *
 * \details
 * Upper half of clock comparison result. This register is updated after
 * clock comparison timer has expired.	In continuous mode this register is
 * periodically updated.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_CMP_VALUEA
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEA  VTSS_IOREG(0x1e, 0, 0xee6b)

/** 
 * \brief
 * Clock comparison value (difference between clk0 and clk1), bits [31:16]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEA . CLK_CMP_VALUE_MSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEA_CLK_CMP_VALUE_MSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEA_CLK_CMP_VALUE_MSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEA_CLK_CMP_VALUE_MSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief DFT clock comparison value
 *
 * \details
 * Lower half of clock comparison result. This register is updated after
 * clock comparison timer has expired.	In continuous mode this register is
 * periodically updated.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_CMP_VALUEB
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEB  VTSS_IOREG(0x1e, 0, 0xee6c)

/** 
 * \brief
 * Clock comparison value (difference between clk0 and clk1), bits [15:0]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEB . CLK_CMP_VALUE_LSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEB_CLK_CMP_VALUE_LSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEB_CLK_CMP_VALUE_LSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_VALUEB_CLK_CMP_VALUE_LSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief DFT clock comparison maximum value
 *
 * \details
 * Upper half of clock comparison max result.  Can be used to judge e.g.
 * SSC clock deviation.  This register is updated after clock comparison
 * timer has expired.  In continuous mode this register is periodically
 * updated.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_CMP_MAXVALA
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALA  VTSS_IOREG(0x1e, 0, 0xee6d)

/** 
 * \brief
 * Clock comparison max value (maximum measured difference between clk0 and
 * clk1), bits [31:16]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALA . CLK_CMP_MAXVAL_MSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALA_CLK_CMP_MAXVAL_MSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALA_CLK_CMP_MAXVAL_MSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALA_CLK_CMP_MAXVAL_MSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief DFT clock comparison maximum value
 *
 * \details
 * Lower half of clock comparison max result.  Can be used to judge e.g.
 * SSC clock deviation.  This register is updated after clock comparison
 * timer has expired.  In continuous mode this register is periodically
 * updated.
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_CMP_MAXVALB
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALB  VTSS_IOREG(0x1e, 0, 0xee6e)

/** 
 * \brief
 * Clock comparison max value (maximum measured difference between clk0 and
 * clk1), bits [15:0]
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALB . CLK_CMP_MAXVAL_LSB
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALB_CLK_CMP_MAXVAL_LSB(x)  VTSS_ENCODE_BITFIELD(x,0,16)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALB_CLK_CMP_MAXVAL_LSB     VTSS_ENCODE_BITMASK(0,16)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_CMP_MAXVALB_CLK_CMP_MAXVAL_LSB(x)  VTSS_EXTRACT_BITFIELD(x,0,16)


/** 
 * \brief DFT TX Error insertion configuration register
 *
 * \details
 * Configuration register for explicit error insertion into DFT driven data
 * stream. Allows to insert expected errors to check e.g. TX/RX
 * connectivity
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_TX_ERR_INSERT_CFG_1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1  VTSS_IOREG(0x1e, 0, 0xee6f)

/** 
 * \brief
 * Preload value for clock generator timer
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1 . CG_TIMER_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1_CG_TIMER_CFG(x)  VTSS_ENCODE_BITFIELD(x,6,10)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1_CG_TIMER_CFG     VTSS_ENCODE_BITMASK(6,10)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1_CG_TIMER_CFG(x)  VTSS_EXTRACT_BITFIELD(x,6,10)

/** 
 * \brief
 * Trigger a single error or a burst of errors (refer to num_err_cfg)
 *
 * \details 
 * 0 to 1 (edge) activates this function
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1 . ERR_TRIG_ONESHOT_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1_ERR_TRIG_ONESHOT_CFG  VTSS_BIT(4)

/** 
 * \brief
 * Frequency of continous/limited error insertion in steps of 40 bits
 *
 * \details 
 * 0: disable continous insertion 1-15: step between 2 errors =
 * 2^(err_freq_cfg + 5) 40 bit words (refer also to err_posit_offs_cfg)
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1 . ERR_FREQ_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1_ERR_FREQ_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,4)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1_ERR_FREQ_CFG     VTSS_ENCODE_BITMASK(0,4)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_1_ERR_FREQ_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,4)


/** 
 * \brief DFT TX Error insertion configuration register
 *
 * \details
 * Configuration register for explicit error insertion into DFT driven data
 * stream. Allows to insert expected errors to check e.g. TX/RX
 * connectivity
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_TX_ERR_INSERT_CFG_2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2  VTSS_IOREG(0x1e, 0, 0xee70)

/** 
 * \brief
 * Position within 40 bit word where an error is inserted by inverting the
 * bit value
 *
 * \details 
 * 0: LSB
 * 39: MSB
 * 40-63: reserved
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2 . ERR_POSIT_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2_ERR_POSIT_CFG(x)  VTSS_ENCODE_BITFIELD(x,10,6)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2_ERR_POSIT_CFG     VTSS_ENCODE_BITMASK(10,6)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2_ERR_POSIT_CFG(x)  VTSS_EXTRACT_BITFIELD(x,10,6)

/** 
 * \brief
 * Offset of bitposition increased per inserted error; allows 'walking'
 * error. Offset is reset when continous/limited error insertion is
 * disabled or burst mode is enabled and burst insertion is finished or
 * err_posit_offs_cfg = 0
 *
 * \details 
 * 0: disabled
 * 1: move 1 bit (from LSB to MSB)
 * ...
 * 39: move 39 bit (from LSB to MSB)
 * 40-63: reserved
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2 . ERR_POSIT_OFFS_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2_ERR_POSIT_OFFS_CFG(x)  VTSS_ENCODE_BITFIELD(x,4,6)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2_ERR_POSIT_OFFS_CFG     VTSS_ENCODE_BITMASK(4,6)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2_ERR_POSIT_OFFS_CFG(x)  VTSS_EXTRACT_BITFIELD(x,4,6)

/** 
 * \brief
 * limited error insertion: burst mode (err_freq_cfg must be > 0)
 *
 * \details 
 * 0: burst mode is disabled 1-15: number of errors after each error
 * triggering = 2^(num_err_cfg + 5)
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2 . NUM_ERR_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2_NUM_ERR_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,4)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2_NUM_ERR_CFG     VTSS_ENCODE_BITMASK(0,4)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_TX_ERR_INSERT_CFG_2_NUM_ERR_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,4)


/** 
 * \brief DFT clock generator configuration register
 *
 * \details
 * Configuration register for clock generator to build a low speed clock
 * signal of variable length and variable duty cycle provided on all data
 * bits simultaniously
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_GEN_CFG_1
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_1  VTSS_IOREG(0x1e, 0, 0xee71)

/** 
 * \brief
 * (Half) clock period cfg in normal mode: high period = cg_per_cfg +
 * cg_dcd_cfg, low period = cg_per_cfg - cg_dcd_cfg
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_1 . CG_PER_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_1_CG_PER_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,10)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_1_CG_PER_CFG     VTSS_ENCODE_BITMASK(0,10)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_1_CG_PER_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,10)


/** 
 * \brief DFT clock generator configuration register
 *
 * \details
 * Configuration register for clock generator to build a low speed clock
 * signal of variable length and variable duty cycle provided on all data
 * bits simultaniously
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_GEN_CFG_2
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_2  VTSS_IOREG(0x1e, 0, 0xee72)

/** 
 * \brief
 * (Half) clock period cfg in jump mode: high period = cg_per_cfg +
 * cg_dcd_cfg, low period = cg_per_cfg - cg_dcd_cfg
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_2 . CG_PER_JUMP_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_2_CG_PER_JUMP_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,10)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_2_CG_PER_JUMP_CFG     VTSS_ENCODE_BITMASK(0,10)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_2_CG_PER_JUMP_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,10)


/** 
 * \brief DFT clock generator configuration register
 *
 * \details
 * Configuration register for clock generator to build a low speed clock
 * signal of variable length and variable duty cycle provided on all data
 * bits simultaniously
 *
 * Register: \a F2DF_DF2F_16BIT:SD10G65_DFT:DFT_CLK_GEN_CFG_3
 */
#define VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_3  VTSS_IOREG(0x1e, 0, 0xee73)

/** 
 * \brief
 * Duty cycle distortion: high period = cg_per_cfg + cg_dcd_cfg, low period
 * = cg_per_cfg - cg_dcd_cfg
 *
 * \details 
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_3 . CG_DCD_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_3_CG_DCD_CFG(x)  VTSS_ENCODE_BITFIELD(x,2,10)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_3_CG_DCD_CFG     VTSS_ENCODE_BITMASK(2,10)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_3_CG_DCD_CFG(x)  VTSS_EXTRACT_BITFIELD(x,2,10)

/** 
 * \brief
 * clock generator mode
 *
 * \details 
 * 0: normal operation
 * cg_per_cfg controls period; 0->1 transition: after current period has
 * finished (only) the next period is controlled by cg_per_jump_cfg
 * afterwards normal operation; 2: every N'th period the high value is
 * replaced by a low value
 * N is defined by cg_timer_cfg; 3: every N'th period the low value is
 * replaced by a high value
 * N is defined by cg_timer_cfg
 *
 * Field: VTSS_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_3 . CG_MODE_CFG
 */
#define  VTSS_F_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_3_CG_MODE_CFG(x)  VTSS_ENCODE_BITFIELD(x,0,2)
#define  VTSS_M_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_3_CG_MODE_CFG     VTSS_ENCODE_BITMASK(0,2)
#define  VTSS_X_F2DF_DF2F_16BIT_SD10G65_DFT_DFT_CLK_GEN_CFG_3_CG_MODE_CFG(x)  VTSS_EXTRACT_BITFIELD(x,0,2)


#endif /* _VTSS_MALIBU_REGS_F2DF_DF2F_16BIT_H_ */
